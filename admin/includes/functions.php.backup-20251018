<?php
// includes/functions.php - Funzioni database e trasformazioni

// Connessione database
function connectDB($config) {
    try {
        $dsn = "mysql:host={$config['host']};port={$config['port']};dbname={$config['database']};charset=utf8mb4";
        $pdo = new PDO($dsn, $config['username'], $config['password']);
        $pdo->setAttribute(PDO::ATTR_ERRMODE, PDO::ERRMODE_EXCEPTION);
        return $pdo;
    } catch (PDOException $e) {
        throw new Exception("Errore connessione: " . $e->getMessage());
    }
}

// Test connessione
function testConnection($config) {
    try {
        $pdo = connectDB($config);
        return ['success' => true, 'message' => 'Connessione riuscita!'];
    } catch (Exception $e) {
        return ['success' => false, 'message' => $e->getMessage()];
    }
}

// Lista tabelle
function getTables($config) {
    $pdo = connectDB($config);
    $stmt = $pdo->query("SHOW TABLES");
    return $stmt->fetchAll(PDO::FETCH_COLUMN);
}

// Colonne tabella (supporta anche JOIN)
function getTableColumns($config, $table = null) {
    $pdo = connectDB($config);
    $columns = [];

    // Se $table è null, usa la configurazione tabelle con JOIN
    if ($table === null) {
        $tableConfig = loadTableConfig();
        if (!$tableConfig) {
            throw new Exception("Configurazione tabelle non trovata. Configura le tabelle prima.");
        }

        // Colonne dalla tabella principale
        $mainTable = $tableConfig['mainTable'];
        $stmt = $pdo->query("SHOW COLUMNS FROM `$mainTable`");
        while ($row = $stmt->fetch(PDO::FETCH_ASSOC)) {
            $columns[] = [
                'name' => $row['Field'],
                'type' => $row['Type'],
                'nullable' => $row['Null'] === 'YES',
                'table' => $mainTable
            ];
        }

        // Colonne dalle tabelle joindate
        if (!empty($tableConfig['joins'])) {
            foreach ($tableConfig['joins'] as $join) {
                $joinTable = $join['table'];
                // Se alias è vuoto o non impostato, usa il nome della tabella
                $alias = (!empty($join['alias'])) ? $join['alias'] : $joinTable;

                $stmt = $pdo->query("SHOW COLUMNS FROM `$joinTable`");
                while ($row = $stmt->fetch(PDO::FETCH_ASSOC)) {
                    $columns[] = [
                        'name' => $alias . '.' . $row['Field'],
                        'type' => $row['Type'],
                        'nullable' => $row['Null'] === 'YES',
                        'table' => $joinTable,
                        'alias' => $alias
                    ];
                }
            }
        }
    } else {
        // Modalità legacy: carica solo una tabella specifica
        $stmt = $pdo->query("SHOW COLUMNS FROM `$table`");
        while ($row = $stmt->fetch(PDO::FETCH_ASSOC)) {
            $columns[] = [
                'name' => $row['Field'],
                'type' => $row['Type'],
                'nullable' => $row['Null'] === 'YES'
            ];
        }
    }

    return $columns;
}

// Fetch prodotti (con supporto JOIN)
function fetchProducts($config, $limit = null) {
    $pdo = connectDB($config);

    // Prova a caricare la configurazione tabelle con JOIN
    $tableConfig = loadTableConfig();

    if ($tableConfig) {
        // Usa la nuova modalità con JOIN
        $sql = buildSelectQuery($tableConfig, '', $limit);
    } else {
        // Fallback: modalità legacy senza JOIN
        $table = $config['table'];
        $sql = "SELECT * FROM `$table`";
        if ($limit) {
            $sql .= " LIMIT " . intval($limit);
        }
    }

    $stmt = $pdo->query($sql);
    return $stmt->fetchAll(PDO::FETCH_ASSOC);
}

// Applica trasformazione
function applyTransform($value, $transform) {
    if (empty($transform) || $value === null) {
        return $value;
    }

    switch ($transform) {
        case 'parseFloat':
            // Converte a float e forza esattamente 2 decimali per evitare problemi di precisione
            return (float)number_format((float)$value, 2, '.', '');
        case 'parseInt':
            return intval($value);
        case 'toUpperCase':
            return strtoupper($value);
        case 'toLowerCase':
            return strtolower($value);
        case 'trim':
            return trim($value);
        default:
            return $value;
    }
}

// Trasforma riga
function transformRow($row, $mappings, $resourceConfig = null) {
    $product = ['attributi' => []];
    $generateDescription = false;

    foreach ($mappings as $mapping) {
        $dbColumn = $mapping['dbColumn'];

        // Prova a ottenere il valore con il nome completo
        $value = isset($row[$dbColumn]) ? $row[$dbColumn] : null;

        // Se non trovato e il nome contiene un punto (alias.campo), prova senza l'alias
        if ($value === null && strpos($dbColumn, '.') !== false) {
            $parts = explode('.', $dbColumn, 2);
            if (count($parts) === 2) {
                $columnWithoutAlias = $parts[1];
                $value = isset($row[$columnWithoutAlias]) ? $row[$columnWithoutAlias] : null;
            }
        }

        // Applica mappatura booleana se presente
        if (!empty($mapping['isBoolean']) && !empty($mapping['booleanMap'])) {
            $value = applyBooleanMapping($value, $mapping['booleanMap']);
        }
        // Altrimenti applica trasformazione normale
        elseif (!empty($mapping['transform'])) {
            $value = applyTransform($value, $mapping['transform']);
        }

        // Assegna al campo giusto
        if ($mapping['isAttribute'] && !empty($mapping['attributeName'])) {
            $product['attributi'][$mapping['attributeName']] = $value;
        } else {
            $product[$mapping['targetField']] = $value;
        }

        // Segna se la descrizione deve essere generata da attributi
        if ($mapping['targetField'] === 'descrizione' && !empty($mapping['generateFromAttributes'])) {
            $generateDescription = true;
        }
    }

    // Genera descrizione automatica da attributi se richiesto
    if ($generateDescription) {
        $descriptionParts = [];

        // Inizia con il nome prodotto
        if (!empty($product['nome'])) {
            $descriptionParts[] = $product['nome'];
        }

        // Aggiungi attributi selezionati
        foreach ($mappings as $mapping) {
            if (!empty($mapping['isAttribute']) &&
                !empty($mapping['useInDescription']) &&
                !empty($mapping['attributeName'])) {

                $attrName = $mapping['attributeName'];
                $attrValue = $product['attributi'][$attrName] ?? null;

                // Includi solo se il valore esiste ed è non vuoto (false va incluso se è booleano)
                if ($attrValue !== null && $attrValue !== '') {
                    // Per attributi booleani (controlla il mapping), converti sempre a Si/No
                    if (!empty($mapping['isBoolean'])) {
                        // Converti il valore a boolean se necessario
                        if (is_bool($attrValue)) {
                            $boolValue = $attrValue;
                        } elseif ($attrValue === 'true' || $attrValue === '1' || $attrValue === 1) {
                            $boolValue = true;
                        } elseif ($attrValue === 'false' || $attrValue === '0' || $attrValue === 0) {
                            $boolValue = false;
                        } else {
                            // Se non è riconosciuto, considera come true se non vuoto
                            $boolValue = !empty($attrValue);
                        }

                        $boolText = $boolValue ? 'Si' : 'No';
                        $descriptionParts[] = "$attrName: $boolText";
                    } else {
                        // Attributo normale
                        $descriptionParts[] = "$attrName: $attrValue";
                    }
                }
            }
        }

        // Costruisci la descrizione finale
        if (!empty($descriptionParts)) {
            $product['descrizione'] = implode(' - ', $descriptionParts);
        }
    }

    // Aggiungi risorse se configurate
    if ($resourceConfig === null) {
        $resourceConfig = loadResourceConfig();
    }

    if (!empty($resourceConfig['enabled']) && !empty($product['codice'])) {
        $resources = findProductResources($product['codice'], $resourceConfig);
        if (!empty($resources)) {
            $product['risorse'] = $resources;
        }
    }

    return $product;
}

// Genera JSON completo
function generateProductsJSON($config, $mappings) {
    $rows = fetchProducts($config);
    $products = [];

    foreach ($rows as $row) {
        $products[] = transformRow($row, $mappings);
    }

    $output = [
        'prodotti' => $products,
        'generated_at' => date('c'),
        'total' => count($products),
        'source' => [
            'database' => $config['database'],
            'table' => $config['table']
        ]
    ];

    // Arrotonda tutti i float a 2 decimali prima di ritornare
    $output = roundFloatsRecursive($output, 2);

    return $output;
}

// Arrotonda ricorsivamente tutti i float in un array
function roundFloatsRecursive($data, $decimals = 2) {
    if (is_array($data)) {
        foreach ($data as $key => $value) {
            $data[$key] = roundFloatsRecursive($value, $decimals);
        }
        return $data;
    } elseif (is_float($data)) {
        // Usa number_format per evitare problemi di precisione floating point
        return (float)number_format($data, $decimals, '.', '');
    } elseif (is_numeric($data) && !is_bool($data) && !is_string($data)) {
        // Converti numeric a float e formatta con precisione esatta
        return (float)number_format((float)$data, $decimals, '.', '');
    } else {
        return $data;
    }
}

// Forza 2 decimali nei float all'interno del JSON
function forceDecimalsInJSON($json, $decimals = 2) {
    // Regex per trovare numeri dopo "prezzo": che non hanno decimali o hanno meno di 2 decimali
    // Cattura: "prezzo": 19 o "prezzo": 19.1 e li converte in "prezzo": 19.00 o "prezzo": 19.10
    $json = preg_replace_callback(
        '/"prezzo":\s*(\d+)(?:\.(\d{1}))?([,\}\s\n\r])/',
        function($matches) use ($decimals) {
            $intPart = $matches[1];
            $decPart = isset($matches[2]) ? $matches[2] : '';
            $after = $matches[3];

            // Aggiungi decimali mancanti
            $decPart = str_pad($decPart, $decimals, '0');

            return '"prezzo": ' . $intPart . '.' . $decPart . $after;
        },
        $json
    );

    // Gestisci anche il caso in cui ci sono già 2+ decimali ma vogliamo forzare esattamente 2
    $json = preg_replace(
        '/"prezzo":\s*(\d+)\.(\d{2})\d+([,\}\s\n\r])/',
        '"prezzo": $1.$2$3',
        $json
    );

    return $json;
}

// Salva JSON pubblico
function savePublicJSON($jsonData) {
    // Arrotonda tutti i float a 2 decimali prima di encodare
    $jsonData = roundFloatsRecursive($jsonData, 2);

    // Imposta precisione JSON (14 è un buon compromesso)
    ini_set('serialize_precision', 14);

    $json = json_encode($jsonData, JSON_PRETTY_PRINT | JSON_UNESCAPED_UNICODE);

    // Controlla se JSON encoding è riuscito
    if ($json === false) {
        throw new Exception("Errore durante la codifica JSON: " . json_last_error_msg());
    }

    // Forza 2 decimali fissi sui prezzi
    $json = forceDecimalsInJSON($json, 2);

    // Verifica che la directory esista
    $dir = dirname(PUBLIC_JSON_PATH);
    if (!is_dir($dir)) {
        if (!mkdir($dir, 0755, true)) {
            throw new Exception("Impossibile creare la directory: $dir");
        }
    }

    // Verifica permessi di scrittura
    if (!is_writable($dir)) {
        throw new Exception("La directory non è scrivibile: $dir. Verifica i permessi (deve essere 755 o 777)");
    }

    // Salva il file con controllo errori
    $result = file_put_contents(PUBLIC_JSON_PATH, $json);

    if ($result === false) {
        throw new Exception("Impossibile scrivere il file: " . PUBLIC_JSON_PATH . ". Verifica i permessi.");
    }

    error_log("[SAVE SUCCESS] File salvato: " . PUBLIC_JSON_PATH . " (" . strlen($json) . " bytes)");

    // Crea .htaccess per CORS
    $htaccess = dirname(PUBLIC_JSON_PATH) . '/.htaccess';
    if (!file_exists($htaccess)) {
        $htaccessContent = <<<EOT
Header set Access-Control-Allow-Origin "*"
Header set Content-Type "application/json"
<Files "products.json">
    Require all granted
</Files>
EOT;
        file_put_contents($htaccess, $htaccessContent);
    }

    return true;
}

// Ottieni valori distinct da una colonna
function getDistinctValues($config, $table, $column) {
    $pdo = connectDB($config);
    $sql = "SELECT DISTINCT `$column` FROM `$table` WHERE `$column` IS NOT NULL ORDER BY `$column`";
    $stmt = $pdo->query($sql);
    $values = [];

    while ($row = $stmt->fetch(PDO::FETCH_NUM)) {
        $value = $row[0];
        // Includi anche valori vuoti ma non NULL
        if ($value !== null) {
            $values[] = $value;
        }
    }

    return $values;
}

// Applica mappatura booleana
function applyBooleanMapping($value, $booleanMap) {
    if (!is_array($booleanMap) || empty($booleanMap)) {
        return $value;
    }

    // Normalizza il valore per il confronto
    $normalizedValue = trim(strtoupper((string)$value));

    // Cerca nel mapping
    foreach ($booleanMap as $dbValue => $boolValue) {
        $normalizedDbValue = trim(strtoupper((string)$dbValue));
        if ($normalizedValue === $normalizedDbValue) {
            return $boolValue === 'true' || $boolValue === true;
        }
    }

    // Se non trovato, ritorna il valore originale
    return $value;
}

// ==================== TABELLE E JOIN ====================

// Carica configurazione tabelle
function loadTableConfig() {
    $tableFile = DATA_PATH . '/table-config.json';
    if (file_exists($tableFile)) {
        return json_decode(file_get_contents($tableFile), true);
    }
    return null;
}

// Salva configurazione tabelle
function saveTableConfig($config) {
    $tableFile = DATA_PATH . '/table-config.json';
    $result = file_put_contents($tableFile, json_encode($config, JSON_PRETTY_PRINT));

    if ($result === false) {
        error_log("Failed to save table config to: $tableFile");
        throw new Exception("Impossibile salvare la configurazione tabelle. Verifica i permessi della directory.");
    }

    return $result;
}

// Costruisce query SQL con JOIN
function buildSelectQuery($tableConfig, $whereClause = '', $limit = null) {
    $mainTable = $tableConfig['mainTable'];
    $joins = $tableConfig['joins'] ?? [];

    // SELECT con tutte le colonne
    $selectParts = ["`$mainTable`.*"];

    // Aggiungi colonne da tabelle joindate
    foreach ($joins as $join) {
        // Se alias è vuoto o non impostato, usa il nome della tabella
        $alias = (!empty($join['alias'])) ? $join['alias'] : $join['table'];
        // Seleziona tutte le colonne dalla tabella joindata con alias
        $selectParts[] = "`$alias`.*";
    }

    $sql = "SELECT " . implode(", ", $selectParts) . " FROM `$mainTable`";

    // Aggiungi JOIN
    foreach ($joins as $join) {
        $joinTable = $join['table'];
        // Se alias è vuoto o non impostato, usa il nome della tabella
        $alias = (!empty($join['alias'])) ? $join['alias'] : $joinTable;
        $type = strtoupper($join['type'] ?? 'LEFT');
        $on = $join['on'];

        $sql .= " $type JOIN `$joinTable` AS `$alias` ON $on";
    }

    // Aggiungi WHERE
    if ($whereClause) {
        $sql .= $whereClause;
    }

    // Aggiungi LIMIT
    if ($limit) {
        $sql .= " LIMIT " . intval($limit);
    }

    return $sql;
}

// ==================== FILTRI ====================

// Carica configurazione filtri
function loadFilterConfig() {
    $filterFile = DATA_PATH . '/filter-config.json';
    if (file_exists($filterFile)) {
        return json_decode(file_get_contents($filterFile), true);
    }
    return [];
}

// Salva configurazione filtri
function saveFilterConfig($filters) {
    $filterFile = DATA_PATH . '/filter-config.json';
    $result = file_put_contents($filterFile, json_encode($filters, JSON_PRETTY_PRINT));

    if ($result === false) {
        error_log("Failed to save filter config to: $filterFile");
        throw new Exception("Impossibile salvare i filtri. Verifica i permessi della directory.");
    }

    return $result;
}

// Helper function per formattare correttamente i nomi delle colonne con backtick
function formatColumnName($column) {
    // Se contiene spazi, è un nome colonna singolo (anche se ha punti)
    // Esempio: "Pos. Assoluto" -> `Pos. Assoluto`
    if (strpos($column, ' ') !== false) {
        return "`$column`";
    }

    // Se contiene un punto (alias.colonna), separa e metti backtick su entrambe le parti
    // Esempio: "cod_con_img.default_image" -> `cod_con_img`.`default_image`
    if (strpos($column, '.') !== false) {
        $parts = explode('.', $column, 2);
        return "`{$parts[0]}`.`{$parts[1]}`";
    }

    // Altrimenti metti backtick solo sulla colonna
    // Esempio: "codice" -> `codice`
    return "`$column`";
}

// Costruisci WHERE clause SQL dai filtri
function buildFilterSQL($filters, &$params) {
    if (empty($filters)) {
        return '';
    }

    $conditions = [];
    $paramIndex = 0;

    foreach ($filters as $filter) {
        $column = $filter['column'];
        $formattedColumn = formatColumnName($column);
        $operator = $filter['operator'];
        $value = $filter['value'] ?? '';
        $logic = $filter['logic'] ?? 'AND';

        $condition = '';

        switch ($operator) {
            case 'equals':
                $condition = "$formattedColumn = :param$paramIndex";
                $params[":param$paramIndex"] = $value;
                $paramIndex++;
                break;

            case 'not_equals':
                $condition = "$formattedColumn != :param$paramIndex";
                $params[":param$paramIndex"] = $value;
                $paramIndex++;
                break;

            case 'contains':
                $condition = "$formattedColumn LIKE :param$paramIndex";
                $params[":param$paramIndex"] = "%$value%";
                $paramIndex++;
                break;

            case 'not_contains':
                $condition = "$formattedColumn NOT LIKE :param$paramIndex";
                $params[":param$paramIndex"] = "%$value%";
                $paramIndex++;
                break;

            case 'starts_with':
                $condition = "$formattedColumn LIKE :param$paramIndex";
                $params[":param$paramIndex"] = "$value%";
                $paramIndex++;
                break;

            case 'ends_with':
                $condition = "$formattedColumn LIKE :param$paramIndex";
                $params[":param$paramIndex"] = "%$value";
                $paramIndex++;
                break;

            case 'is_empty':
                $condition = "($formattedColumn IS NULL OR $formattedColumn = '')";
                break;

            case 'is_not_empty':
                $condition = "($formattedColumn IS NOT NULL AND $formattedColumn != '')";
                break;

            case 'greater_than':
                $condition = "$formattedColumn > :param$paramIndex";
                $params[":param$paramIndex"] = $value;
                $paramIndex++;
                break;

            case 'less_than':
                $condition = "$formattedColumn < :param$paramIndex";
                $params[":param$paramIndex"] = $value;
                $paramIndex++;
                break;

            case 'greater_equal':
                $condition = "$formattedColumn >= :param$paramIndex";
                $params[":param$paramIndex"] = $value;
                $paramIndex++;
                break;

            case 'less_equal':
                $condition = "$formattedColumn <= :param$paramIndex";
                $params[":param$paramIndex"] = $value;
                $paramIndex++;
                break;
        }

        if ($condition) {
            // Se è OR con il precedente e c'è almeno una condizione, combina
            if ($logic === 'OR' && !empty($conditions)) {
                $lastIndex = count($conditions) - 1;
                $conditions[$lastIndex] .= " OR $condition";
            } else {
                $conditions[] = $condition;
            }
        }
    }

    if (empty($conditions)) {
        return '';
    }

    return ' WHERE ' . implode(' AND ', array_map(function($c) {
        // Raggruppa condizioni OR tra parentesi se contengono OR
        return strpos($c, ' OR ') !== false ? "($c)" : $c;
    }, $conditions));
}

// Fetch prodotti con filtri (con supporto JOIN)
function fetchProductsWithFilters($config, $filters = [], $limit = null) {
    $pdo = connectDB($config);
    $params = [];

    // Prova a caricare la configurazione tabelle con JOIN
    $tableConfig = loadTableConfig();

    if ($tableConfig) {
        // Usa la nuova modalità con JOIN
        $whereClause = buildFilterSQL($filters, $params);
        $sql = buildSelectQuery($tableConfig, $whereClause, $limit);
    } else {
        // Fallback: modalità legacy senza JOIN
        $table = $config['table'];
        $sql = "SELECT * FROM `$table`";
        $whereClause = buildFilterSQL($filters, $params);
        $sql .= $whereClause;

        if ($limit) {
            $sql .= " LIMIT " . intval($limit);
        }
    }

    $stmt = $pdo->prepare($sql);

    // Bind parametri
    foreach ($params as $key => $value) {
        $stmt->bindValue($key, $value);
    }

    $stmt->execute();
    return $stmt->fetchAll(PDO::FETCH_ASSOC);
}

// Conta prodotti con filtri (con supporto JOIN)
function countProductsWithFilters($config, $filters = []) {
    $pdo = connectDB($config);
    $params = [];

    // Prova a caricare la configurazione tabelle con JOIN
    $tableConfig = loadTableConfig();

    if ($tableConfig) {
        // Usa la nuova modalità con JOIN
        $mainTable = $tableConfig['mainTable'];
        $joins = $tableConfig['joins'] ?? [];

        $sql = "SELECT COUNT(*) FROM `$mainTable`";

        // Aggiungi JOIN
        foreach ($joins as $join) {
            $joinTable = $join['table'];
            // Se alias è vuoto o non impostato, usa il nome della tabella
            $alias = (!empty($join['alias'])) ? $join['alias'] : $joinTable;
            $type = strtoupper($join['type'] ?? 'LEFT');
            $on = $join['on'];

            $sql .= " $type JOIN `$joinTable` AS `$alias` ON $on";
        }

        // Aggiungi filtri
        $whereClause = buildFilterSQL($filters, $params);
        $sql .= $whereClause;
    } else {
        // Fallback: modalità legacy
        $table = $config['table'];
        $sql = "SELECT COUNT(*) FROM `$table`";
        $whereClause = buildFilterSQL($filters, $params);
        $sql .= $whereClause;
    }

    $stmt = $pdo->prepare($sql);

    // Bind parametri
    foreach ($params as $key => $value) {
        $stmt->bindValue($key, $value);
    }

    $stmt->execute();
    return $stmt->fetchColumn();
}

// ==================== TRADUZIONI ====================

// Carica impostazioni traduzioni
function loadTranslationSettings() {
    $settingsFile = DATA_PATH . '/translation-settings.json';
    if (file_exists($settingsFile)) {
        return json_decode(file_get_contents($settingsFile), true);
    }
    return ['enabled' => false, 'languages' => ['it'], 'api_key' => ''];
}

// Ottieni/Salva dalla cache traduzioni
function getTranslationCache($text, $targetLang) {
    $cacheFile = DATA_PATH . '/translation-cache.json';
    if (!file_exists($cacheFile)) {
        return null;
    }

    $cache = json_decode(file_get_contents($cacheFile), true);
    $key = md5($text . '_' . $targetLang);

    if (isset($cache[$key])) {
        return $cache[$key];
    }

    return null;
}

function saveTranslationCache($text, $targetLang, $translation) {
    $cacheFile = DATA_PATH . '/translation-cache.json';
    $cache = [];

    if (file_exists($cacheFile)) {
        $cache = json_decode(file_get_contents($cacheFile), true) ?: [];
    }

    $key = md5($text . '_' . $targetLang);
    $cache[$key] = $translation;

    file_put_contents($cacheFile, json_encode($cache, JSON_PRETTY_PRINT));
}

// Log errori traduzioni
function logTranslationError($message, $details = []) {
    $logFile = DATA_PATH . '/translation-errors.log';
    $timestamp = date('Y-m-d H:i:s');
    $logEntry = "[$timestamp] $message";

    if (!empty($details)) {
        $logEntry .= ' | Details: ' . json_encode($details);
    }

    $logEntry .= "\n";
    file_put_contents($logFile, $logEntry, FILE_APPEND);
}

// Traduci testo con Claude
function translateText($text, $targetLang, $apiKey) {
    if (empty($text)) {
        return $text;
    }

    // Non tradurre se il testo è solo spazi vuoti
    if (trim($text) === '') {
        return $text;
    }

    if (empty($apiKey)) {
        logTranslationError('API Key missing', ['text' => substr($text, 0, 50), 'lang' => $targetLang]);
        return $text;
    }

    // Controlla cache
    $cached = getTranslationCache($text, $targetLang);
    if ($cached !== null) {
        return $cached;
    }

    $languageNames = [
        'en' => 'English',
        'de' => 'German',
        'fr' => 'French',
        'es' => 'Spanish',
        'pt' => 'Portuguese'
    ];

    $targetLanguageName = $languageNames[$targetLang] ?? $targetLang;

    $prompt = "Translate the following Italian text to {$targetLanguageName}.
Keep the same tone and meaning. Return ONLY the translation, no explanations.

Text to translate: \"{$text}\"

Translation:";

    try {
        $ch = curl_init('https://api.anthropic.com/v1/messages');

        if ($ch === false) {
            logTranslationError('cURL init failed', ['text' => substr($text, 0, 50), 'lang' => $targetLang]);
            return $text;
        }

        curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);
        curl_setopt($ch, CURLOPT_POST, true);
        curl_setopt($ch, CURLOPT_HTTPHEADER, [
            'Content-Type: application/json',
            'x-api-key: ' . $apiKey,
            'anthropic-version: 2023-06-01'
        ]);
        curl_setopt($ch, CURLOPT_POSTFIELDS, json_encode([
            'model' => 'claude-3-5-sonnet-20241022',
            'max_tokens' => 500,
            'messages' => [
                ['role' => 'user', 'content' => $prompt]
            ]
        ]));

        $response = curl_exec($ch);
        $curlError = curl_error($ch);
        $httpCode = curl_getinfo($ch, CURLINFO_HTTP_CODE);
        curl_close($ch);

        if ($response === false) {
            logTranslationError('cURL execution failed', [
                'error' => $curlError,
                'text' => substr($text, 0, 50),
                'lang' => $targetLang
            ]);
            return $text;
        }

        if ($httpCode !== 200) {
            logTranslationError("API returned HTTP $httpCode", [
                'response' => substr($response, 0, 500),
                'text' => substr($text, 0, 50),
                'lang' => $targetLang,
                'api_key_prefix' => substr($apiKey, 0, 10) . '...'
            ]);
            return $text;
        }

        $data = json_decode($response, true);

        if (json_last_error() !== JSON_ERROR_NONE) {
            logTranslationError('JSON decode error', [
                'error' => json_last_error_msg(),
                'response' => substr($response, 0, 200)
            ]);
            return $text;
        }

        if (isset($data['content'][0]['text'])) {
            $translation = trim($data['content'][0]['text']);

            // Salva in cache
            saveTranslationCache($text, $targetLang, $translation);

            return $translation;
        }

        logTranslationError('Unexpected API response format', [
            'response_keys' => array_keys($data ?? []),
            'text' => substr($text, 0, 50)
        ]);

        return $text;

    } catch (Exception $e) {
        logTranslationError('Exception caught', [
            'exception' => $e->getMessage(),
            'text' => substr($text, 0, 50),
            'lang' => $targetLang
        ]);
        return $text;
    }
}

// Traduci batch di testi (più efficiente)
function translateBatch($texts, $targetLang, $apiKey) {
    if (empty($texts) || empty($apiKey)) {
        return array_fill(0, count($texts), '');
    }

    $translations = [];
    $toTranslate = [];
    $indices = [];

    // Controlla cache per ogni testo
    foreach ($texts as $index => $text) {
        $cached = getTranslationCache($text, $targetLang);
        if ($cached !== null) {
            $translations[$index] = $cached;
        } else {
            $toTranslate[] = $text;
            $indices[] = $index;
        }
    }

    // Traduci i testi mancanti in batch
    if (!empty($toTranslate)) {
        $languageNames = [
            'en' => 'English',
            'de' => 'German',
            'fr' => 'French',
            'es' => 'Spanish',
            'pt' => 'Portuguese'
        ];

        $targetLanguageName = $languageNames[$targetLang] ?? $targetLang;

        $textList = implode("\n", array_map(function($i, $text) {
            return ($i + 1) . ". \"$text\"";
        }, array_keys($toTranslate), $toTranslate));

        $prompt = "Translate these Italian texts to {$targetLanguageName}.
Keep the same tone and meaning. Return ONLY the translations, one per line, in the same order.
Do not include numbering or explanations.

Texts to translate:
{$textList}

Translations:";

        try {
            $ch = curl_init('https://api.anthropic.com/v1/messages');
            curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);
            curl_setopt($ch, CURLOPT_POST, true);
            curl_setopt($ch, CURLOPT_HTTPHEADER, [
                'Content-Type: application/json',
                'x-api-key: ' . $apiKey,
                'anthropic-version: 2023-06-01'
            ]);
            curl_setopt($ch, CURLOPT_POSTFIELDS, json_encode([
                'model' => 'claude-3-5-sonnet-20241022',
                'max_tokens' => 2000,
                'messages' => [
                    ['role' => 'user', 'content' => $prompt]
                ]
            ]));

            $response = curl_exec($ch);
            $httpCode = curl_getinfo($ch, CURLINFO_HTTP_CODE);
            curl_close($ch);

            if ($httpCode === 200) {
                $data = json_decode($response, true);
                if (isset($data['content'][0]['text'])) {
                    $translatedLines = explode("\n", trim($data['content'][0]['text']));

                    foreach ($indices as $i => $originalIndex) {
                        if (isset($translatedLines[$i])) {
                            $translation = trim($translatedLines[$i]);
                            $translations[$originalIndex] = $translation;

                            // Salva in cache
                            saveTranslationCache($toTranslate[$i], $targetLang, $translation);
                        } else {
                            $translations[$originalIndex] = $toTranslate[$i];
                        }
                    }
                }
            }

        } catch (Exception $e) {
            error_log("Batch translation error: " . $e->getMessage());
            // Fallback: usa testi originali
            foreach ($indices as $i => $originalIndex) {
                $translations[$originalIndex] = $toTranslate[$i];
            }
        }
    }

    // Riordina per indice
    ksort($translations);
    return array_values($translations);
}

// Ottieni etichette campi base tradotte
function getBaseFieldLabels() {
    return [
        'codice' => [
            'it' => 'Codice',
            'en' => 'Code',
            'de' => 'Code',
            'fr' => 'Code',
            'es' => 'Código',
            'pt' => 'Código'
        ],
        'nome' => [
            'it' => 'Nome',
            'en' => 'Name',
            'de' => 'Name',
            'fr' => 'Nom',
            'es' => 'Nombre',
            'pt' => 'Nome'
        ],
        'descrizione' => [
            'it' => 'Descrizione',
            'en' => 'Description',
            'de' => 'Beschreibung',
            'fr' => 'Description',
            'es' => 'Descripción',
            'pt' => 'Descrição'
        ],
        'prezzo' => [
            'it' => 'Prezzo',
            'en' => 'Price',
            'de' => 'Preis',
            'fr' => 'Prix',
            'es' => 'Precio',
            'pt' => 'Preço'
        ],
        'immagine' => [
            'it' => 'Immagine',
            'en' => 'Image',
            'de' => 'Bild',
            'fr' => 'Image',
            'es' => 'Imagen',
            'pt' => 'Imagem'
        ]
    ];
}

// Genera JSON completo con supporto multilingua
function generateProductsJSONMultilang($config, $mappings, $translationSettings, $productLimit = null, $filters = [], $imageSettings = [], $variantConfig = [], $ecommerceConfig = []) {
    // Fetch prodotti con limite opzionale e filtri
    if (!empty($filters)) {
        $rows = fetchProductsWithFilters($config, $filters, $productLimit);
    } else {
        $rows = fetchProducts($config, $productLimit);
    }
    $products = [];

    // Trasforma ogni prodotto usando la logica esistente
    foreach ($rows as $row) {
        // Usa immagini multiple se abilitate
        if (!empty($imageSettings['enabled'])) {
            $products[] = transformRowWithImages($row, $mappings, $imageSettings);
        } else {
            $products[] = transformRow($row, $mappings);
        }
    }

    // IMPORTANTE: Genera metadati e-commerce DAI PRODOTTI BASE (prima del raggruppamento varianti)
    // per assicurarsi di raccogliere TUTTI i valori unici
    $ecommerceMeta = [];
    if (!empty($ecommerceConfig)) {
        error_log("[ECOMMERCE META] Generazione metadati da " . count($products) . " prodotti base");
        // Usa prodotti NON raggruppati per estrarre tutti i valori
        $ecommerceMeta = generateEcommerceMeta($ecommerceConfig, $products, ['it'], false);

        // Log risultati
        if (!empty($ecommerceMeta['filters'])) {
            foreach ($ecommerceMeta['filters'] as $filter) {
                $optCount = !empty($filter['options']) ? count($filter['options']) : 0;
                error_log("[ECOMMERCE META] Filtro '{$filter['field']}': {$optCount} opzioni raccolte");
            }
        }
    }

    // ⚠️ NUOVO: Applica raggruppamento varianti PRIMA delle traduzioni
    if (!empty($variantConfig['enabled'])) {
        $products = groupProductsByVariants($products, $rows, $variantConfig);
    }

    // Se le traduzioni non sono abilitate, ritorna formato base
    if (empty($translationSettings['enabled']) || empty($translationSettings['api_key'])) {

        $meta = [
            'languages' => ['it'],
            'variants_enabled' => !empty($variantConfig['enabled'])
        ];

        // Merge e-commerce meta
        if (!empty($ecommerceMeta['filters'])) {
            $meta['filters'] = $ecommerceMeta['filters'];
        }
        if (!empty($ecommerceMeta['categories'])) {
            $meta['categories'] = $ecommerceMeta['categories'];
        }

        return [
            'prodotti' => $products,
            'generated_at' => date('c'),
            'total' => count($products),
            'source' => [
                'database' => $config['database'],
                'table' => $config['table']
            ],
            '_meta' => $meta
        ];
    }

    // Lingue target (sempre include IT come base)
    $languages = $translationSettings['languages'];
    if (!in_array('it', $languages)) {
        array_unshift($languages, 'it');
    }

    $apiKey = $translationSettings['api_key'];

    // Traduci i prodotti
    $multilingualProducts = [];

    foreach ($products as $product) {
        $mlProduct = $product;

        // Converti nome e descrizione in oggetti multilingua
        if ($translationSettings['translate_name'] && isset($product['nome'])) {
            $mlProduct['nome'] = ['it' => $product['nome']];

            // Traduci per ogni lingua target
            foreach ($languages as $lang) {
                if ($lang !== 'it') {
                    $mlProduct['nome'][$lang] = translateText($product['nome'], $lang, $apiKey);
                }
            }
        }

        if ($translationSettings['translate_description'] && isset($product['descrizione'])) {
            $mlProduct['descrizione'] = ['it' => $product['descrizione']];

            // Traduci per ogni lingua target
            foreach ($languages as $lang) {
                if ($lang !== 'it') {
                    $mlProduct['descrizione'][$lang] = translateText($product['descrizione'], $lang, $apiKey);
                }
            }
        }

        // Traduci attributi se abilitato
        if ($translationSettings['translate_attributes'] && !empty($product['attributi'])) {
            $mlAttributes = [];

            foreach ($product['attributi'] as $attrKey => $attrValue) {
                $mlAttr = [
                    'label' => ['it' => $attrKey],
                    'value' => []
                ];

                // Traduci il nome dell'attributo (label)
                foreach ($languages as $lang) {
                    if ($lang !== 'it') {
                        $mlAttr['label'][$lang] = translateText($attrKey, $lang, $apiKey);
                    }
                }

                // Traduci il valore se è testuale (non boolean, non numerico)
                if (is_string($attrValue) && !is_numeric($attrValue) && !is_bool($attrValue)) {
                    $mlAttr['value']['it'] = $attrValue;

                    foreach ($languages as $lang) {
                        if ($lang !== 'it') {
                            $mlAttr['value'][$lang] = translateText($attrValue, $lang, $apiKey);
                        }
                    }
                } elseif (is_bool($attrValue)) {
                    // Per booleani, mantieni il valore diretto
                    $mlAttr['value'] = $attrValue;
                } else {
                    // Per numeri o altri tipi, mantieni il valore diretto
                    $mlAttr['value'] = $attrValue;
                }

                $mlAttributes[$attrKey] = $mlAttr;
            }

            $mlProduct['attributi'] = $mlAttributes;
        }

        // ⚠️ IMPORTANTE: Traduci anche gli attributi delle varianti!
        if ($translationSettings['translate_attributes'] && !empty($mlProduct['variants'])) {
            $mlVariants = [];

            foreach ($mlProduct['variants'] as $variant) {
                $mlVariant = $variant;

                // Traduci gli attributi della variante
                if (!empty($variant['attributi'])) {
                    $mlVariantAttributes = [];

                    foreach ($variant['attributi'] as $attrKey => $attrValue) {
                        $mlAttr = [
                            'label' => ['it' => $attrKey],
                            'value' => []
                        ];

                        // Traduci il nome dell'attributo (label)
                        foreach ($languages as $lang) {
                            if ($lang !== 'it') {
                                $mlAttr['label'][$lang] = translateText($attrKey, $lang, $apiKey);
                            }
                        }

                        // Traduci il valore se è testuale (non boolean, non numerico)
                        if (is_string($attrValue) && !is_numeric($attrValue) && !is_bool($attrValue)) {
                            $mlAttr['value']['it'] = $attrValue;

                            foreach ($languages as $lang) {
                                if ($lang !== 'it') {
                                    $mlAttr['value'][$lang] = translateText($attrValue, $lang, $apiKey);
                                }
                            }
                        } elseif (is_bool($attrValue)) {
                            // Per booleani, mantieni il valore diretto
                            $mlAttr['value'] = $attrValue;
                        } else {
                            // Per numeri o altri tipi, mantieni il valore diretto
                            $mlAttr['value'] = $attrValue;
                        }

                        $mlVariantAttributes[$attrKey] = $mlAttr;
                    }

                    $mlVariant['attributi'] = $mlVariantAttributes;
                }

                $mlVariants[] = $mlVariant;
            }

            $mlProduct['variants'] = $mlVariants;
        }

        $multilingualProducts[] = $mlProduct;
    }

    // Ottieni etichette campi base tradotte
    $baseLabels = getBaseFieldLabels();

    // Filtra solo le lingue abilitate
    $filteredLabels = [];
    foreach ($baseLabels as $field => $translations) {
        $filteredLabels[$field] = [];
        foreach ($languages as $lang) {
            if (isset($translations[$lang])) {
                $filteredLabels[$field][$lang] = $translations[$lang];
            }
        }
    }

    // Traduci i metadati e-commerce generati prima (da prodotti base)
    // Questo aggiunge le traduzioni alle options già raccolte
    // Usa approccio batch per ridurre numero di chiamate API
    if (!empty($ecommerceMeta['filters'])) {
        // Traduci la label del filtro UNA VOLTA PER TUTTI I FILTRI
        $filterLabelTranslationsByField = [];

        foreach ($ecommerceMeta['filters'] as &$filter) {
            if (!empty($filter['options']) && is_array($filter['options'])) {
                // Traduci la label del filtro se non l'abbiamo già fatto
                if (!isset($filterLabelTranslationsByField[$filter['field']])) {
                    $filterLabelTranslations = ['it' => $filter['label']];
                    foreach ($languages as $lang) {
                        if ($lang !== 'it') {
                            $filterLabelTranslations[$lang] = translateText($filter['label'], $lang, $apiKey);
                        }
                    }
                    $filterLabelTranslationsByField[$filter['field']] = $filterLabelTranslations;
                }

                $filterLabelTranslations = $filterLabelTranslationsByField[$filter['field']];
                $translatedOptions = [];

                // Raccogli tutti i valori UNICI da tradurre per questo filtro
                $valuesToTranslate = [];
                foreach ($filter['options'] as $option) {
                    // Le options hanno struttura {label: {it: ...}, value: {it: ...}} o {label: {...}, value: {...}}
                    $italianValue = null;

                    if (is_array($option) && isset($option['value'])) {
                        // Caso 1: value è un array con chiave 'it'
                        if (is_array($option['value']) && isset($option['value']['it'])) {
                            $italianValue = trim($option['value']['it']);
                        }
                        // Caso 2: value è una stringa diretta
                        elseif (is_string($option['value'])) {
                            $italianValue = trim($option['value']);
                        }
                    }

                    // Aggiungi solo valori validi e non duplicati
                    if ($italianValue !== null && $italianValue !== '' && !in_array($italianValue, $valuesToTranslate, true)) {
                        $valuesToTranslate[] = $italianValue;
                    }
                }

                // Traduci i valori in batch per ogni lingua (più efficiente)
                $translationsByLang = [];
                foreach ($languages as $lang) {
                    if ($lang !== 'it') {
                        error_log("[TRANSLATION] Translating {$filter['field']} values to $lang (batch of " . count($valuesToTranslate) . ")");
                        $translationsByLang[$lang] = translateBatch($valuesToTranslate, $lang, $apiKey);
                        // Piccola pausa tra le lingue per evitare rate limiting
                        usleep(100000); // 100ms
                    }
                }

                // Ricostruisci TUTTE le options con traduzioni complete
                foreach ($valuesToTranslate as $idx => $italianValue) {
                    $mlOption = [
                        'label' => $filterLabelTranslations, // Usa traduzioni complete della label
                        'value' => ['it' => $italianValue]
                    ];

                    // Aggiungi traduzioni da batch
                    foreach ($languages as $lang) {
                        if ($lang !== 'it') {
                            $mlOption['value'][$lang] = $translationsByLang[$lang][$idx] ?? $italianValue;
                        }
                    }

                    $translatedOptions[] = $mlOption;
                }

                $filter['options'] = $translatedOptions;
            }
        }
        unset($filter); // Rompi il reference
    }

    // Costruisci _meta
    $meta = [
        'languages' => $languages,
        'translation_settings' => [
            'translate_name' => $translationSettings['translate_name'],
            'translate_description' => $translationSettings['translate_description'],
            'translate_attributes' => $translationSettings['translate_attributes']
        ]
    ];

    // Merge e-commerce meta
    if (!empty($ecommerceMeta['filters'])) {
        $meta['filters'] = $ecommerceMeta['filters'];
    }
    if (!empty($ecommerceMeta['categories'])) {
        // Aggiorna le traduzioni delle categorie usando i prodotti tradotti
        foreach ($ecommerceMeta['categories'] as &$category) {
            $categoryTranslations = null;

            // Cerca nei prodotti tradotti per trovare le traduzioni complete
            foreach ($multilingualProducts as $product) {
                if (isset($product['attributi'][$category['field']])) {
                    $categoryAttr = $product['attributi'][$category['field']];

                    // Estrai le traduzioni dalla label dell'attributo
                    if (is_array($categoryAttr) && isset($categoryAttr['label']) && is_array($categoryAttr['label'])) {
                        if (!$categoryTranslations || count($categoryAttr['label']) > count($categoryTranslations)) {
                            $categoryTranslations = $categoryAttr['label'];
                        }
                    }
                }
            }

            // Aggiorna le traduzioni se trovate
            if ($categoryTranslations) {
                $category['translations'] = $categoryTranslations;
            }
        }
        unset($category); // Rimuovi reference

        $meta['categories'] = $ecommerceMeta['categories'];
    }

    // Costruisci output finale
    $output = [
        '_labels' => $filteredLabels,
        'prodotti' => $multilingualProducts,
        'generated_at' => date('c'),
        'total' => count($multilingualProducts),
        'source' => [
            'database' => $config['database'],
            'table' => $config['table']
        ],
        '_meta' => $meta
    ];

    // Arrotonda tutti i float a 2 decimali prima di ritornare
    $output = roundFloatsRecursive($output, 2);

    return $output;
}

// ==================== IMMAGINI MULTIPLE ====================

/**
 * Scansiona il filesystem e trova tutte le immagini per un prodotto
 * Usa il nome file dell'immagine principale dal DB come base per la ricerca
 *
 * @param string $mainImageUrl URL immagine principale dal DB (es: "https://didieffeb2b.com/img_catalogo_norm/FAA00245U0IR____.JPG")
 * @param string $imagesPath Path assoluto della cartella immagini (es: "/home/user/public_html/img_catalogo_norm/")
 * @param string $publicBaseUrl URL pubblico base (es: "https://didieffeb2b.com/img_catalogo_norm/")
 * @return array Array di URL immagini ordinate (prima principale, poi gallery)
 */
function scanProductImages($mainImageUrl, $imagesPath, $publicBaseUrl) {
    // Se non c'è immagine principale o path, ritorna array vuoto
    if (empty($mainImageUrl) || empty($imagesPath) || !is_dir($imagesPath)) {
        return $mainImageUrl ? [$mainImageUrl] : [];
    }

    // Normalizza path (assicura trailing slash)
    $imagesPath = rtrim($imagesPath, '/') . '/';
    $publicBaseUrl = rtrim($publicBaseUrl, '/') . '/';

    // Estrai il nome file dall'URL principale
    $mainFileName = basename($mainImageUrl);

    // Estrai nome base e estensione
    $pathInfo = pathinfo($mainFileName);
    $baseName = $pathInfo['filename']; // Nome senza estensione
    $extension = $pathInfo['extension'] ?? 'jpg';

    // Rimuovi eventuali underscore finali e numeri per ottenere il pattern base
    // Es: "FAA00245U0IR____" → "FAA00245U0IR"
    // Es: "FOTO_GENERICA_001" → "FOTO_GENERICA_001"
    $basePattern = preg_replace('/_+\d*$/', '', $baseName);

    // Se dopo la pulizia il pattern è vuoto, usa il nome completo
    if (empty($basePattern)) {
        $basePattern = $baseName;
    }

    // Cerca tutti i file che iniziano con il pattern base
    $foundFiles = [];
    $extensions = ['jpg', 'JPG', 'jpeg', 'JPEG', 'png', 'PNG', 'gif', 'GIF'];

    foreach ($extensions as $ext) {
        $pattern = $imagesPath . $basePattern . '*.' . $ext;
        $matches = glob($pattern);
        if ($matches) {
            $foundFiles = array_merge($foundFiles, $matches);
        }
    }

    // Se non trova file, ritorna solo immagine principale
    if (empty($foundFiles)) {
        return [$mainImageUrl];
    }

    // Rimuovi duplicati (glob potrebbe trovare lo stesso file con case diverso)
    $foundFiles = array_unique($foundFiles);

    // Ordina i file per nome (questo mette l'immagine principale prima e poi 01, 02, 03...)
    sort($foundFiles);

    // Converti path assoluti in URL pubblici
    $images = [];
    foreach ($foundFiles as $filePath) {
        $fileName = basename($filePath);
        $images[] = $publicBaseUrl . $fileName;
    }

    return $images;
}

/**
 * Carica impostazioni immagini da config
 */
function loadImageSettings() {
    $imageFile = DATA_PATH . '/image-settings.json';
    if (file_exists($imageFile)) {
        return json_decode(file_get_contents($imageFile), true);
    }
    return [
        'enabled' => false,
        'images_path' => '',
        'public_base_url' => 'https://didieffeb2b.com/img_catalogo_norm/'
    ];
}

/**
 * Salva impostazioni immagini
 */
function saveImageSettings($settings) {
    $imageFile = DATA_PATH . '/image-settings.json';
    return file_put_contents($imageFile, json_encode($settings, JSON_PRETTY_PRINT));
}

/**
 * Wrapper: trasforma riga con supporto immagini multiple
 *
 * Questa è una versione estesa di transformRow che include la scansione immagini
 */
function transformRowWithImages($row, $mappings, $imageSettings = null, $resourceConfig = null) {
    // Trasformazione base (include già le risorse)
    $product = transformRow($row, $mappings, $resourceConfig);

    // Se immagini multiple non abilitate, ritorna prodotto base
    if (empty($imageSettings) || empty($imageSettings['enabled'])) {
        return $product;
    }

    $publicBaseUrl = $imageSettings['public_base_url'] ?? 'https://didieffeb2b.com/img_catalogo_norm/';
    $imagesPath = $imageSettings['images_path'] ?? '';

    // Determina l'URL dell'immagine principale da usare per la scansione
    $mainImageValue = null;

    if (!empty($product['immagine'])) {
        // Caso 1: Il prodotto ha già un campo immagine dal mapping
        $mainImageValue = $product['immagine'];

        // Se l'immagine dal DB è solo un nome file (non contiene http:// o https://),
        // costruisci l'URL completo
        if (strpos($mainImageValue, 'http://') !== 0 && strpos($mainImageValue, 'https://') !== 0) {
            $mainImageValue = rtrim($publicBaseUrl, '/') . '/' . ltrim($mainImageValue, '/');
        }
    } elseif (!empty($product['codice']) && !empty($imagesPath) && is_dir($imagesPath)) {
        // Caso 2: Nessuna immagine dal DB, ma abbiamo il codice prodotto
        // Proviamo a cercare l'immagine direttamente nel filesystem usando il pattern codice____
        $productCode = $product['codice'];
        $extensions = ['jpg', 'JPG', 'jpeg', 'JPEG', 'png', 'PNG'];

        foreach ($extensions as $ext) {
            $pattern = rtrim($imagesPath, '/') . '/' . $productCode . '____.' . $ext;
            $matches = glob($pattern);
            if (!empty($matches)) {
                $mainImageValue = rtrim($publicBaseUrl, '/') . '/' . basename($matches[0]);
                break;
            }
        }
    }

    // Se abbiamo trovato un'immagine (da DB o da filesystem), scansiona per gallery
    if (!empty($mainImageValue)) {
        $images = scanProductImages(
            $mainImageValue,
            $imagesPath,
            $publicBaseUrl
        );

        // Aggiungi array immagini solo se trova più di una immagine
        if (count($images) > 1) {
            $product['immagini'] = $images;
            // Assicura che immagine principale sia la prima della gallery
            $product['immagine'] = $images[0];
        } elseif (count($images) === 1) {
            // Se trova solo una, assicura che sia settata come principale
            $product['immagine'] = $images[0];
        }
    }

    return $product;
}

// ==================== VARIANTI PRODOTTO ====================

/**
 * Carica configurazione varianti
 */
function loadVariantConfig() {
    $variantFile = DATA_PATH . '/variant-config.json';
    if (file_exists($variantFile)) {
        return json_decode(file_get_contents($variantFile), true);
    }
    return [
        'enabled' => false,
        'groupByField' => '',
        'orderByField' => '',
        'qualifiers' => []
    ];
}

/**
 * Salva configurazione varianti
 */
function saveVariantConfig($config) {
    $variantFile = DATA_PATH . '/variant-config.json';
    return file_put_contents($variantFile, json_encode($config, JSON_PRETTY_PRINT));
}

/**
 * Raggruppa prodotti per varianti secondo configurazione
 *
 * @param array $products Array di prodotti trasformati
 * @param array $rawRows Array delle righe DB originali (per accedere ai campi di raggruppamento)
 * @param array $variantConfig Configurazione varianti
 * @return array Array di prodotti con varianti aggregate
 */
function groupProductsByVariants($products, $rawRows, $variantConfig) {
    if (empty($variantConfig['enabled']) || empty($variantConfig['groupByField'])) {
        // Se varianti disabilitate, ritorna prodotti così come sono
        return $products;
    }

    $groupByField = $variantConfig['groupByField'];
    $orderByField = $variantConfig['orderByField'] ?? '';
    $qualifiers = $variantConfig['qualifiers'] ?? [];

    // Helper: cerca campo in modo case-insensitive e flessibile
    $findFieldValue = function($row, $fieldName) {
        // 1. Prova esattamente come configurato
        if (isset($row[$fieldName])) {
            return $row[$fieldName];
        }

        // 2. Prova senza alias (se ha punto)
        if (strpos($fieldName, '.') !== false) {
            $parts = explode('.', $fieldName, 2);
            if (count($parts) === 2 && isset($row[$parts[1]])) {
                return $row[$parts[1]];
            }
        }

        // 3. Prova case-insensitive
        $fieldLower = strtolower($fieldName);
        foreach ($row as $key => $value) {
            if (strtolower($key) === $fieldLower) {
                return $value;
            }
        }

        // 4. Prova case-insensitive senza alias
        if (strpos($fieldName, '.') !== false) {
            $parts = explode('.', $fieldName, 2);
            if (count($parts) === 2) {
                $fieldLower = strtolower($parts[1]);
                foreach ($row as $key => $value) {
                    if (strtolower($key) === $fieldLower) {
                        return $value;
                    }
                }
            }
        }

        return null;
    };

    // Crea array di mapping prodotto -> raw row per accedere ai campi DB
    $productToRow = [];
    foreach ($products as $index => $product) {
        $productToRow[$index] = $rawRows[$index];
    }

    // Raggruppa prodotti per variantGroupId
    $groups = [];
    foreach ($products as $index => $product) {
        $rawRow = $productToRow[$index];

        // Ottieni valore campo aggregatore dalla riga DB
        $groupId = $findFieldValue($rawRow, $groupByField);

        // Se non ha groupId, salta (o aggiungilo come prodotto singolo)
        if ($groupId === null || $groupId === '') {
            // Aggiungi comunque come prodotto singolo senza varianti
            $groups['_single_' . $index] = [[
                'product' => $product,
                'order' => 0
            ]];
            continue;
        }

        // Ottieni ordinamento se configurato
        $orderValue = 0;
        if (!empty($orderByField)) {
            $orderValue = $findFieldValue($rawRow, $orderByField);
            if ($orderValue === null) {
                $orderValue = 0;
            }
        }

        if (!isset($groups[$groupId])) {
            $groups[$groupId] = [];
        }

        $groups[$groupId][] = [
            'product' => $product,
            'order' => $orderValue
        ];
    }

    // Per ogni gruppo, crea prodotto master con varianti
    $result = [];
    foreach ($groups as $groupId => $groupProducts) {
        // Ordina le varianti
        usort($groupProducts, function($a, $b) {
            return $a['order'] <=> $b['order'];
        });

        // Il primo prodotto diventa master
        $masterProduct = $groupProducts[0]['product'];

        // Se c'è un solo prodotto nel gruppo, non serve aggregazione
        if (count($groupProducts) === 1) {
            $result[] = $masterProduct;
            continue;
        }

        // Crea array varianti
        $variants = [];
        foreach ($groupProducts as $idx => $item) {
            $variantProduct = $item['product'];

            // Estrai qualificatori dagli attributi
            $variantQualifiers = [];
            foreach ($qualifiers as $qualifier) {
                $attrName = $qualifier['attributeName'];
                if (isset($variantProduct['attributi'][$attrName])) {
                    $variantQualifiers[$attrName] = $variantProduct['attributi'][$attrName];
                }
            }

            $variants[] = [
                'codice' => $variantProduct['codice'] ?? '',
                'variantOrder' => $idx + 1,
                'qualifiers' => $variantQualifiers,
                'prezzo' => $variantProduct['prezzo'] ?? null,
                'immagine' => $variantProduct['immagine'] ?? null,
                'immagini' => $variantProduct['immagini'] ?? null,
                'attributi' => $variantProduct['attributi'] ?? []
            ];
        }

        // Costruisci prodotto master con varianti
        $masterWithVariants = $masterProduct;
        $masterWithVariants['variantGroupId'] = (string)$groupId;
        $masterWithVariants['isVariantGroup'] = true;
        $masterWithVariants['variants'] = $variants;

        $result[] = $masterWithVariants;
    }

    return $result;
}

// ==================== RISORSE SCARICABILI ====================

/**
 * Carica configurazione risorse
 */
function loadResourceConfig() {
    $resourceFile = DATA_PATH . '/resource-config.json';
    if (file_exists($resourceFile)) {
        return json_decode(file_get_contents($resourceFile), true);
    }
    return [
        'enabled' => false,
        'baseUrl' => '',
        'categories' => []
    ];
}

/**
 * Salva configurazione risorse
 */
function saveResourceConfig($config) {
    $resourceFile = DATA_PATH . '/resource-config.json';
    return file_put_contents($resourceFile, json_encode($config, JSON_PRETTY_PRINT));
}

/**
 * Trova risorse per un codice prodotto
 *
 * @param string $productCode Codice prodotto
 * @param array $resourceConfig Configurazione risorse
 * @return array Array di risorse trovate con formato: ['category' => 'PDF', 'url' => '...', 'icon' => '📄']
 */
function findProductResources($productCode, $resourceConfig) {
    if (empty($resourceConfig['enabled']) || empty($resourceConfig['categories'])) {
        return [];
    }

    $resources = [];
    $baseUrl = rtrim($resourceConfig['baseUrl'], '/');

    foreach ($resourceConfig['categories'] as $category) {
        $categoryName = $category['name'];
        $folder = $category['folder'];
        $extensions = $category['extensions'] ?? [];
        $icon = $category['icon'] ?? '📄';

        // Prova ogni estensione finché non ne trova una esistente
        foreach ($extensions as $ext) {
            $ext = strtolower(trim($ext));
            $url = "{$baseUrl}/{$folder}/{$productCode}.{$ext}";

            // Verifica se il file esiste effettivamente
            if (checkRemoteFileExists($url)) {
                $resources[] = [
                    'category' => $categoryName,
                    'url' => $url,
                    'icon' => $icon,
                    'extension' => $ext
                ];

                // Trovata l'estensione esistente per questa categoria, passa alla prossima
                break;
            }
        }
    }

    return $resources;
}

/**
 * Verifica se un URL remoto è accessibile (HTTP HEAD request)
 * Usato per verificare se le risorse esistono realmente
 */
function checkRemoteFileExists($url) {
    $ch = curl_init($url);
    if ($ch === false) {
        return false;
    }

    curl_setopt($ch, CURLOPT_NOBODY, true);
    curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);
    curl_setopt($ch, CURLOPT_TIMEOUT, 3);
    curl_setopt($ch, CURLOPT_FOLLOWLOCATION, true);

    curl_exec($ch);
    $httpCode = curl_getinfo($ch, CURLINFO_HTTP_CODE);
    curl_close($ch);

    return $httpCode === 200;
}

// ==================== CONFIGURAZIONE E-COMMERCE ====================

/**
 * Carica configurazione e-commerce (filtri e categorie)
 */
function loadEcommerceConfig() {
    $ecommerceFile = DATA_PATH . '/ecommerce-config.json';
    if (file_exists($ecommerceFile)) {
        return json_decode(file_get_contents($ecommerceFile), true);
    }
    return [
        'filters' => [],
        'categories' => []
    ];
}

/**
 * Salva configurazione e-commerce
 */
function saveEcommerceConfig($config) {
    $ecommerceFile = DATA_PATH . '/ecommerce-config.json';
    return file_put_contents($ecommerceFile, json_encode($config, JSON_PRETTY_PRINT));
}

/**
 * Genera sezione _meta per e-commerce con filtri e categorie
 *
 * @param array $ecommerceConfig Configurazione e-commerce
 * @param array $products Array prodotti (possono essere multilingua se traduzioni abilitate)
 * @param array $languages Array delle lingue abilitate (default: ['it'])
 * @param bool $translateAttributes Se gli attributi sono tradotti (default: false)
 * @return array Sezione _meta per JSON
 */
function generateEcommerceMeta($ecommerceConfig, $products, $languages = ['it'], $translateAttributes = false) {
    $meta = [
        'filters' => [],
        'categories' => []
    ];

    // Helper per estrarre valore tradotto in italiano (lingua base)
    $getItalianValue = function($attrValue) {
        if (is_array($attrValue)) {
            // Attributo multilingua con struttura {label: {...}, value: {...}}
            if (isset($attrValue['value'])) {
                $value = $attrValue['value'];
                if (is_array($value) && isset($value['it'])) {
                    return trim($value['it']);
                } elseif (is_string($value)) {
                    return trim($value);
                }
            }
        }
        // Valore semplice (non tradotto)
        return is_string($attrValue) ? trim($attrValue) : $attrValue;
    };

    // Genera metadati filtri
    if (!empty($ecommerceConfig['filters'])) {
        foreach ($ecommerceConfig['filters'] as $filter) {
            if ($filter['enabled']) {
                $filterMeta = [
                    'field' => $filter['field'],
                    'type' => $filter['type'],
                    'label' => $filter['label'],
                    'order' => $filter['order']
                ];

                // Per filtri select/checkbox, aggiungi valori disponibili con traduzioni
                if (in_array($filter['type'], ['select', 'checkbox', 'tags'])) {
                    // Raccogli tutti i valori UNICI da tutti i prodotti E dalle loro varianti
                    // Usa valore italiano come chiave per de-duplicare
                    $uniqueValues = [];

                    // Helper per elaborare un singolo prodotto/variante
                    $processProduct = function($product) use ($filter, $translateAttributes, &$uniqueValues) {
                        if (isset($product['attributi'][$filter['field']])) {
                            $attrValue = $product['attributi'][$filter['field']];

                            if ($attrValue === null || $attrValue === '') {
                                return;
                            }

                            // Se è un attributo multilingua tradotto
                            if ($translateAttributes && is_array($attrValue) && isset($attrValue['value'])) {
                                $valueObj = $attrValue['value'];

                                // Estrai valore italiano come chiave univoca
                                $italianKey = '';
                                if (is_array($valueObj) && isset($valueObj['it'])) {
                                    $italianKey = trim($valueObj['it']);
                                } elseif (is_string($valueObj)) {
                                    $italianKey = trim($valueObj);
                                } else {
                                    // Booleani o numerici
                                    $italianKey = (string)$valueObj;
                                }

                                if ($italianKey === '') return;

                                // Salva l'intero oggetto tradotto usando italiano come chiave
                                if (!isset($uniqueValues[$italianKey])) {
                                    $uniqueValues[$italianKey] = [
                                        'label' => $attrValue['label'] ?? [],
                                        'value' => $valueObj
                                    ];
                                }
                            } else {
                                // Valore semplice (non tradotto) - ma dobbiamo comunque creare struttura multilingua per il frontend
                                $simpleValue = is_string($attrValue) ? trim($attrValue) : $attrValue;
                                if ($simpleValue !== '' && !isset($uniqueValues[$simpleValue])) {
                                    // Crea struttura multilingua anche per valori non tradotti
                                    // IMPORTANTE: usa solo IT come base, le traduzioni verranno aggiunte dopo nella fase di traduzione batch
                                    $uniqueValues[$simpleValue] = [
                                        'label' => ['it' => $filter['label']],
                                        'value' => ['it' => $simpleValue]
                                    ];
                                }
                            }
                        }
                    };

                    // Elabora tutti i prodotti
                    foreach ($products as $product) {
                        // Elabora il prodotto master
                        $processProduct($product);

                        // Se il prodotto ha varianti, elabora anche quelle
                        if (!empty($product['variants']) && is_array($product['variants'])) {
                            foreach ($product['variants'] as $variant) {
                                $processProduct($variant);
                            }
                        }
                    }

                    // Converti in array options
                    $options = array_values($uniqueValues);

                    // Ordina sempre per valore italiano (ora tutti hanno struttura multilingua)
                    usort($options, function($a, $b) {
                        // Estrai valore italiano per confronto
                        $aIt = '';
                        $bIt = '';

                        if (is_array($a) && isset($a['value'])) {
                            if (is_array($a['value']) && isset($a['value']['it'])) {
                                $aIt = $a['value']['it'];
                            } elseif (is_string($a['value'])) {
                                $aIt = $a['value'];
                            }
                        }

                        if (is_array($b) && isset($b['value'])) {
                            if (is_array($b['value']) && isset($b['value']['it'])) {
                                $bIt = $b['value']['it'];
                            } elseif (is_string($b['value'])) {
                                $bIt = $b['value'];
                            }
                        }

                        return strcasecmp($aIt, $bIt);
                    });

                    $filterMeta['options'] = $options;
                }

                // Per filtri range, calcola min/max
                if ($filter['type'] === 'range') {
                    if ($filter['field'] === 'prezzo') {
                        $prices = array_column($products, 'prezzo');
                        // Rimuovi valori null o vuoti
                        $prices = array_filter($prices, function($p) {
                            return $p !== null && $p !== '';
                        });

                        if (!empty($prices)) {
                            $filterMeta['min'] = min($prices);
                            $filterMeta['max'] = max($prices);
                        } else {
                            // Valori default se non ci sono prezzi
                            $filterMeta['min'] = 0;
                            $filterMeta['max'] = 0;
                        }
                    }
                }

                $meta['filters'][] = $filterMeta;
            }
        }

        // Ordina filtri per order
        usort($meta['filters'], function($a, $b) {
            return $a['order'] <=> $b['order'];
        });
    }

    // Genera metadati categorie
    if (!empty($ecommerceConfig['categories'])) {
        foreach ($ecommerceConfig['categories'] as $category) {
            if ($category['enabled']) {
                // Cerca le traduzioni della categoria dai prodotti
                // Le categorie sono attributi booleani, quindi cerchiamo l'attributo con il nome della categoria
                $categoryTranslations = null;
                $count = 0;

                foreach ($products as $product) {
                    // Cerca l'attributo con il nome della categoria (es. "Scuri alla Veneta")
                    if (isset($product['attributi'][$category['field']])) {
                        $categoryAttr = $product['attributi'][$category['field']];

                        // Estrai le traduzioni dalla label dell'attributo
                        // Prendi solo se ha traduzioni complete (più di una lingua)
                        if (is_array($categoryAttr) && isset($categoryAttr['label']) && is_array($categoryAttr['label'])) {
                            if (!$categoryTranslations || count($categoryAttr['label']) > count($categoryTranslations)) {
                                $categoryTranslations = $categoryAttr['label'];
                            }
                        }

                        // Conta i prodotti che hanno questo attributo = true
                        if (is_array($categoryAttr) && isset($categoryAttr['value'])) {
                            $val = $categoryAttr['value'];
                        } else {
                            $val = $categoryAttr;
                        }

                        if ($val === true || $val === 'true' || $val === 1 || $val === '1') {
                            $count++;
                        }
                    }
                }

                $meta['categories'][] = [
                    'field' => $category['field'],
                    'label' => $category['label'],
                    'translations' => $categoryTranslations ?? ['it' => $category['label']], // Fallback alla label config
                    'icon' => $category['icon'],
                    'image' => $category['image'] ?? '', // NUOVO: Campo immagine
                    'color' => $category['color'],
                    'description' => $category['description'],
                    'count' => $count
                ];
            }
        }
    }

    return $meta;
}
?>
